#' Summarize the orthologues for each genetype or chromosome
#'
#' @param x
#' Data frame with ortholog annotations for corresponding species. It is generated
#' using ortholog_match(species_list=c()).
#' @param group
#' genetype or chrom, the number of genes for each group based on specified
#' tags will be listed.
#'
#' @return
#' Data frame with the count of genes for each genetype or chrom in each species.
#'
#' @examples
#' hs2mm2ss.orth <- ortholog_match(species_list=c("human", "mouse","pig"))
#' summarize_ortholog_gene(hs2mm2ss.orth, "genetype")
#'
#' @export
summarize_ortholog_gene <- function(x, group = c("genetype", "chrom")){
# check x
if(missing(x)){
stop("x not specified.")
}
x <- verify_ortholog_data(x)
# check group
if(missing(group)){
stop("group not specified. Should be: genetype or chrom.")
}
if(length(group)>1){
stop("group should be: genetype or chrom.")
}
group <- tolower(group)
if(!group %in% c("genetype", "chrom")){
stop("group should be: genetype or crom.")
}
# retrieve and summary information
species   <- attr(x, "Species")
gene_grp  <- NULL
gene_cnt  <- list()
for(i in 1:length(x)) {
if(group == "genetype") {
gene_grp      <- unique(c(gene_grp, x[[i]]$GeneType))
gene_cnt[[i]] <- table(x[[i]]$GeneType)
}
if(group == "chrom") {
gene_grp      <- unique(c(gene_grp, x[[i]]$Chrom))
gene_cnt[[i]] <- table(x[[i]]$Chrom)
}
gene_grp <- sort(gene_grp)
mat <- matrix(0, nrow = length(gene_grp), ncol = length(species))
row.names(mat) <- gene_grp
colnames(mat)  <- species
for(i in seq_along(species)) {
mat[match(names(gene_cnt[[i]]), gene_grp),i] = as.vector(gene_cnt[[i]])
}
return(mat)
}
#' Verify if the orthologue matching data is normal
#'
#' Examine given data to see if its format is normal. Further, if no "Species"
#' attribute is present, try to set as Species_1, Species_2 etc, and return
#' the updated data. The species name is required for some other functions.
#'
#' @param x
#' Data with information for paired 1-to-1 orthologous pairs. It should be the
#' list generated using \code{\link{ortholog_match}}.
#'
#' @return
#' List, unchanged/updated data with the same structre as the input data x.
#'
#' @examples
#' hs2mm.orth <- ortholog_match("human", "mouse")
#' hs2mm.orth <- verify_ortholog_data(hs2mm.orth)
#'
#' @export
verify_ortholog_data <- function (x) {
if(missing(x)) {
stop("x not specified.")
}
if(!is.list(x)) {
stop("x should be an object generated using ortholog_match.")
}
if(length(x) == 0) {
stop("x is empty.")
}
if(length(x) < 2) {
warning("x has ", length(x), " items. Expect to be >=2.")
}
for(i in length(x)) {
if(nrow(x[[i]]) < 1){
stop("Element ", i, " of x has 0 row.")
}
if(ncol(x[[i]]) != 4) {
stop("Element ", i, " of x has ", ncol(x[[i]]), " column. Expect 4.")
}
# set Species as Species_n if no "Species" attribute
if(length(attr(x, "Species")) == 0) {
attr(x,"Species") <- paste0("Species_", 1:length(x))
warning("x has no Species attribute. Set to Species_1, Species_2 etc.")
}
if(length(attr(x, "Species")) != length(x)) {
attr(x,"Species") <- paste0("Species_", 1:length(x))
warning("attr(x,\"Species\") has different length to x. Change to Species_1, Species_2 etc.")
}
return(x)
}
#' Convert 1-to-1 orthologous information across multiple species as a matrix
#'
#' Examine given data to see if its format is normal. Further, if no "Species"
#' attribute is present, try to set as Species_1, Species_2 etc, and return
#' the updated data. The species name is required for some other functions.
#'
#' @param x
#' Data with information for paired 1-to-1 orthologous pairs. It should be the
#' list generated using \code{\link{ortholog_match}}.
#'
#' @param gene_attr
#' The information to be merged into the matrix. It should be GeneID or GeneName,
#' which are available for each species in the list generated using
#' \code{\link{ortholog_match}}. Default: GeneID.
#'
#' @return
#' Matrix, with rows as GeneID or GeneName, and columns as species. This matrix
#' can be used for subsequent analysis of the 1:1 orthologs across all the involved
#' species. This is different from the list generated using \code{\link{ortholog_match}},
#' which contains rich information of the orthologs for each species, yet are not
#' merged together as a matrix.
#'
#' @examples
#' hs2mm2ss.orth <- ortholog_match("human", "mouse", "pig")
#' hs2mm2ss.orth.GeneID.matrix <- extract_ortholog_matrix(hs2mm2ss.orth, "GeneID")
#'
#' @export
extract_ortholog_matrix <- function (x, gene_attr = "GeneID") {
if(missing(x)) {
stop("x not specified.")
}
x <- verify_ortholog_data(x)
if(!gene_attr %in% c("GeneID", "GeneName")){
stop("gene_attr should be GeneID or GeneName.")
}
## make the matrix
mat <- matrix(
rep("", nrow(x[[1]]) * length(x)),
nrow = nrow(x[[1]])
)
# colnames: species
colnames(mat) <- attr(x, "Species")
# rownames: the gene_attr for the anchor species
x.anchor <- x[[attr(x, "Species_anchor")]]
row.names(mat) <- x.anchor[,colnames(x.anchor) == gene_attr]
## merge data to the matrix
for(i in 1:length(x)){
z <- x[[i]]
mat[,i] <- z[,colnames(z) == gene_attr]
}
return(mat)
}
################################################################################
#    match 1-to-1 orthologous genes across multiple species
# ------------------------------------------------------------------------------
# ortholog_match
################################################################################
#' Match 1-to-1 ortholog between multiple species
#'
#' Ortholog matching is performed based on the ortholog information retrieved
#' from ENSEMBL. The R package biomaRt is used to access ENSEMBL.To work properly,
#' make sure biomaRt package is installed and the internet connection works.
#' It may take sometime to download data from ENSEMBL - depending on the
#' network speed. Only species with their genomes availale in ENSEMBL database
#' are supported. Use \code{\link{list_species}} to get the information for
#' all the supported species.
#'
#' @param species_list
#' A vector for all the species to be analyzed. Should be common names such as
#' "human", "mouse", etc. Use \code{\link{list_species}} to get the names of all
#' supported species.
#' @param species_anchor
#' A species name from the provided species_list. This species will server as the
#' anchor to be compared against by all other species. Default:The first species
#' from the provided species_list.
#' @param host
#' ENSEMBL host (mirror) to connect to. Default: www.ensembl.org. By default,
#' bioMart uses the latest releases of genome assemblies from the ENSEMBL database,
#' which may not match the genome version of given data sometimes. Earlier releases
#' can be used by specifying an archieved host address, which can be  found from
#' the ENSEMBL website.
#'
#' @return
#' A matrix with the information for 1-to-1 ortholog pairs. The list has corresponding
#' species data frames (each for one species) with columns GeneID, GeneName,
#' Chrom,GeneType. Additonal attributes including Species and SpeciesAbbr are
#' also attached to the return list.
#' @examples
#'
#' # Get 1:1 orthologs between different pairs of species
#' hs2mm.orth <- ortholog_match(species_list = c("human", "mouse"))
#' hs2mm2ss.orth <- ortholog_match(species_list = c("human", "mouse","pig"))
#'
#' #Specify anchor species
#' hs2mm2ss.orth <- ortholog_match(
#‘   species_list = c("human", "mouse","pig"), species_anchor = "human"
#’ )
#'
#' # Choose to use different host (mirrors) for ENSEMBL
#' hs2mm2ss.orth <- ortholog_match(
#’   species_list = c("human", "mouse", "pig"), host = "www.ensembl.org"
#‘ )
#' hs2mm2ss.orth <- ortholog_match(
#’   species_list = c("human", "mouse", "pig"), host = "useast.ensembl.org"
#‘ )
#' hs2mm2ss.orth <- ortholog_match(
#’   species_list = c("human", "mouse", "pig"), host = "asia.ensembl.org"
#‘ )
#'
#' # Choose to use an archieved host for ENSEMBL (it used GRCh38 for human, GRCm38 for mouse, etc)
#' hs2mm2ss.orth <- ortholog_match(
#’   species_list = c("human", "mouse", "pig"), host = "nov2020.archive.ensembl.org"
#‘ )
ortholog_match <- function(species_list, species_anchor, host) {
## check species_list
if(missing(species_list)) {
stop("species_list not specified.")
}
if(length(species_list) < 2) {
stop("At least two species are required for comparison.")
}
## retrieve annotation from Ensembl using biomaRt package
if("biomaRt" %in% rownames(installed.packages())){
library(biomaRt)
}
else{
stop("biomaRt cannot be loaded. Install it first.")
}
## connect to ENSEMBL
if(missing(host)){
mart = useMart("ensembl", verbose = TRUE)
}
else{
mart = useMart("ensembl", verbose = TRUE, host = host)
}
# check if all specified species are supported (by comparing against list_species()),
# and get their abbreviations which will be used by biomaRt
species.ok   <- list_species()
species_list <- tolower(species_list)
species_abbr <- vector("character", length(species_list))
message("Get species name abbreviation to be used by biomaRt ...")
for(sp in seq_along(species_list)){
if(! species_list[sp] %in% tolower(species.ok$Species)){
stop(
species_list[sp], " is not supported. Use list_species() to list all supported species."
)
}
species_abbr[sp] <- species.ok$Dataset[which(tolower(species.ok$Species) == species_list[sp])]
message(species_list[sp], " => ", species_abbr[sp])
}
# biomaRt connection
conn         <- list()
species_data <- list()
message("\nConnect to biomaRt for each species ...")
for(i in seq_along(species_list)){
conn[[i]] <- useDataset(
paste0(species_abbr[i], "_gene_ensembl"), mart, verbose = FALSE
)
species_data[[i]] <- getBM(
attributes = c(
"ensembl_gene_id",
"external_gene_name",
"chromosome_name",
"gene_biotype"
),
mart    = conn[[i]],
filters = "ensembl_gene_id",
values  = ""
)
}
##check anchor species
anchor_idx <- NULL
if(missing(species_anchor)){
species_anchor <- species_list[1]
message(
"\nNo anchor species specified, using the first species as default: ",
species_anchor
)
anchor_idx <- 1
}
else{
if(species_anchor %in% species_list){
anchor_idx <- which(species_list == species_anchor)
message("\nUsing user-specified anchor species: ", species_anchor)
}
else{
stop("\nAnchor species is not in the species list.")
}
anchor   <- species_list[anchor_idx]
anchor_abbr <- species_abbr[anchor_idx]
anchor_data <- species_data[[anchor_idx]]
message("anchor species: ", anchor, " (", nrow(anchor_data), " genes)")
## Get orthologous genes from the anchor species to all other species
ortholog_list <- list()
ortholog_list[[anchor]] <- anchor_data[order(anchor_data$ensembl_gene_id),]
for(i in seq_along(species_list)){
if(i == anchor_idx){
next
}
target      <- species_list[i]
target_abbr <- species_abbr[i]
message(
"\nSearching for orthologous genes between ", anchor,
" and ", target, "..."
)
hom_tag  <- paste0(target_abbr, "_homolog_ensembl_gene")
message(anchor, " => ", target, ": ", hom_tag)
# pairwise check if the homolog table available for species
attr_list <- listAttributes(conn[[anchor_idx]])$name
if(!hom_tag %in% attr_list) {
stop(paste0(anchor, " has no attribute: ", target))
}
homolog_info <- getBM(
attributes = c("ensembl_gene_id","external_gene_name", hom_tag),
mart    = conn[[anchor_idx]],
filters = "ensembl_gene_id",
values  = anchor_data$ensembl_gene_id
)
colnames(homolog_info) <- c("anchor_gene_id", "anchor_gene_name", "target_gene_id")
homolog_info <- homolog_info[homolog_info$target_gene_id != "", ]
message("orthologous genes: ",nrow(homolog_info))
# 1:1 matched genes
anchor_counts <- table(homolog_info$anchor_gene_id)
target_counts <- table(homolog_info$target_gene_id)
anchor_unique <- names(anchor_counts)[anchor_counts == 1]
target_unique <- names(target_counts)[target_counts == 1]
one_to_one <- homolog_info[
homolog_info$anchor_gene_id %in% anchor_unique &
homolog_info$target_gene_id %in% target_unique,
]
message("Found ", nrow(one_to_one), " 1:1 orthologous gene pairs.")
# Get complete gene information for the target species
target_gene_info <- species_data[[i]]
target_orthologs <- merge(
one_to_one,
target_gene_info,
by.x = "target_gene_id",
by.y = "ensembl_gene_id",
all.x = FALSE
)
colnames(target_orthologs)[colnames(target_orthologs) == "target_gene_id"] <-
paste0(target, "_gene_id")
target_orthologs <- dplyr::select(target_orthologs, 2:3, 1, 4:6)
ortholog_list[[target]] <- target_orthologs[order(target_orthologs$anchor_gene_id),]
}
## merge data from all species
message(
"\nFilting orthologous genes across all compared species: ",
paste(names(ortholog_list), collapse = ", ")
)
unified_matrix <- ortholog_list[[anchor]]
for(sp in names(ortholog_list)){
if(sp != anchor){
sp_data <- ortholog_list[[sp]][, c("anchor_gene_id", paste0(sp, "_gene_id"))]
# merge the common genes across species
unified_matrix <- merge(
unified_matrix,
sp_data,
by.x  = "ensembl_gene_id",
by.y  = "anchor_gene_id",
all.x = FALSE
)
}
## Rename column names and output list in the specified format
common_gene_ids <- unified_matrix$ensembl_gene_id
formatted_orthologs <- list()
for(sp in names(ortholog_list)){
sp_data <- ortholog_list[[sp]]
if(sp == anchor) {
filtered_data <- sp_data[sp_data$ensembl_gene_id %in% common_gene_ids, ]
formatted_df <- data.frame(
GeneID = filtered_data$ensembl_gene_id,
GeneName = filtered_data$external_gene_name,
Chrom = filtered_data$chromosome_name,
GeneType = filtered_data$gene_biotype,
stringsAsFactors = FALSE
)
}
else{
filtered_data <- sp_data[sp_data$anchor_gene_id %in% common_gene_ids, ]
formatted_df <- data.frame(
GeneID = filtered_data[,c(paste0(sp,"_gene_id"))],
GeneName = filtered_data$external_gene_name,
Chrom = filtered_data$chromosome_name,
GeneType = filtered_data$gene_biotype,
stringsAsFactors = FALSE
)
}
formatted_orthologs[[sp]] <- formatted_df
}
message("Found ", nrow(formatted_orthologs[[1]]), " 1:1 orthologous genes")
attr(formatted_orthologs, "Unified_matrix") <- unified_matrix
attr(formatted_orthologs, "Species_anchor") <- anchor
attr(formatted_orthologs, "Species")        <- species_list
attr(formatted_orthologs, "SpeciesAbbr")    <- species_abbr
attr(formatted_orthologs, "GeneID_matrix")  <- extract_ortholog_matrix(formatted_orthologs, "GeneID")
attr(formatted_orthologs, "GeneName_matrix")  <- extract_ortholog_matrix(formatted_orthologs, "GeneName")
return(formatted_orthologs)
}
orth5 <- ortholog_match(c("human", "mouse", "pig", "chicken", "horse"))
attributes(orth5)
attr(orth5)
attr(orth5, "GeneID_matrix")
head(attr(orth5, "GeneID_matrix"))
head(attr(orth5, "GeneName_matrix"))
dim(attr(orth5, "GeneName_matrix"))
use_mit_license()
setwd("OrthologMatcher/")
use_mit_license()
load_all()
check()
rm(list = list())
rm(list = ls())
check()
library(roxygen2)
document()
use_vignette()
?use_vignette
?extract_ortholog_matrix
check()
use_package("plyr")
use_package("biomaRt")
check()
load_all()
check()
load_all()
check()
install.packages()
?install.packages()
utils::install.packages()
check()
load_all()
check()
load_all()
check()
load_all()
check()
load_all()
check()
library(knitr)
load_all()
check()
load_all()
check()
use_package(utils)
use_package("utils")
use_package("plyr")
load_all()
check()
load_all()
check()
use_package(plyr)
use_package("plyr")
load_all()
check()
?select
use_package("dplyr")
load_all()
check()
list_species()
list_species("human")
list_species(pattern = "human")
list_species()
library(ExprX)
list_species("human")
list_species("mouse")
load_all()
list_species("mouse")
ortholog_match(c("human", "mouse", "pig"))
ot1 <- ortholog_match(c("human", "mouse", "pig"))
ot1$human
ot1[[1]]
ot1[[2]]
attr(ot1, "GeneID_matrix")
load_all()
check()
load_all()
check()
load_all()
check()
load_all()
list_species()
list_species(pattern = "human")
hs2mm2ss.orth <- ortholog_match(species_list=c("human", "mouse","pig"))
summarize_ortholog_gene(hs2mm2ss.orth, "genetype")
hs2mm.orth <- ortholog_match(c("human", "mouse"))
hs2mm.orth <- verify_ortholog_data(hs2mm.orth)
hs2mm.orth <- ortholog_match(species_list = c("human", "mouse"))
hs2mm2ss.orth <- ortholog_match(species_list = c("human", "mouse", "pig"))
load_all()
check()
hs2mm2ss.orth <- ortholog_match(c("human", "mouse", "pig"))
load_all()
check()
hs2mm2ss.orth <- ortholog_match(c("human", "mouse", "pig"))
hs2mm2ss.orth.GeneID.matrix <- extract_ortholog_matrix(hs2mm2ss.orth, "GeneID")
check()
document()
devtools::build()
devtools::build_manual()
reload()
check()
load_all()
check()
document()
build()
devtools::install_git("https://github.com/mingansun/OrthologMatcher")
